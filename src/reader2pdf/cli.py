# src/reader2pdf/cli.py
from __future__ import annotations

import hashlib
import time
import typer
from pathlib import Path
from playwright.sync_api import sync_playwright, TimeoutError as PWTimeoutError

app = typer.Typer(add_completion=False)

READABILITY_JS_URL = (
    "https://raw.githubusercontent.com/mozilla/readability/master/Readability.js"
)

# Fallback snippet fo fetch + inject Readability.js if not present
INJECT_READABILITY_JS = f"""
(async () => {{
  if (!window.Readability) {{
    const res = await fetch("{READABILITY_JS_URL}", {{cache: "no-store"}});
    const code = await res.text();
    const s = document.createElement('script');
    s.type = 'text/javascript';
    s.text = code;
    document.documentElement.appendChild(s);
  }}
}})();
"""

# Minimal CSS for better readability
MINIMAL_CSS = """
:root { color-scheme: light dark; }
body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, 'Helvetica Neue', Arial, sans-serif;
       line-height: 1.6; max-width: 780px; margin: 2.5rem auto; padding: 0 1rem; }
h1 { line-height: 1.25; font-size: 1.8rem; margin: 0 0 1rem; }
article img, article video, article figure { max-width: 100%; height: auto; }
article pre, article code { white-space: pre-wrap; word-break: break-word; }
a { text-decoration: none; }
hr { border: none; border-top: 1px solid #ccc; margin: 2rem 0; }
header { margin-bottom: 1.25rem; color: #666; font-size: 0.9rem; }
footer { margin-top: 2rem; font-size: 0.8rem; color: #888; }
"""


def sha256_hex(s: str) -> str:
    """
    Return the SHA-256 hash of the given string as a hexadecimal string.
    """
    return hashlib.sha256(s.encode("utf-8")).hexdigest()


def render_article_html(title: str, content_html: str, source_url: str) -> str:
    """
    Build a complete HTML document with the given title, content, and source URL.
    """
    return f"""<!DOCTYPE html>
<html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>{title}</title>
<style>{MINIMAL_CSS}</style>
<body>
<header>Source: <a href="{source_url}">{source_url}</a></header>
<h1>{title}</h1>
<article>{content_html}</article>
<footer><hr>Generated by reader2pdf at {time.strftime("%Y-%m-%d %H:%M:%S")}</footer>
</body>
</html>"""


@app.command(help="Process URLs line-by-line, save PDFs as sha256(url).pdf")
def run(
    url_file: Path = typer.Option(
        ..., "--url-file", "-i", help="Path to text file with one URL per line"
    ),
    out_dir: Path = typer.Option(
        Path("output"), "--out-dir", "-o", help="Output directory for PDFs"
    ),
    timeout_s: int = typer.Option(45, help="Per-URL navigation timeout (seconds)"),
) -> None:
    urls = [
        line.strip()
        for line in url_file.read_text(encoding="utf-8").splitlines()
        if line.strip()
    ]
    out_dir.mkdir(parents=True, exist_ok=True)

    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        ctx = browser.new_context(
            viewport={"width": 1280, "height": 2000},
            java_script_enabled=True,
        )

        for url in urls:
            pdf_name = f"{sha256_hex(url)}.pdf"
            pdf_path = out_dir / pdf_name
            typer.echo(f"[+] {url} -> {pdf_path}")

            page = ctx.new_page()
            try:
                page.goto(url, wait_until="domcontentloaded", timeout=timeout_s * 1000)
                # Let network settle a bit; many sites lazy-load content.
                try:
                    page.wait_for_load_state("networkidle", timeout=10_000)
                except PWTimeoutError:
                    pass  # non-fatal

                # Inject Readability.js
                page.evaluate(INJECT_READABILITY_JS)
                page.wait_for_function(
                    "() => window.Readability !== undefined", timeout=10_000
                )

                # Clone the DOM (Readability recommendation) and parse.
                article = page.evaluate(
                    """() => {
                        const doc = document.cloneNode(true);
                        try {
                          const reader = new Readability(doc);
                          return reader.parse(); // {title, content, textContent, length, excerpt, byline, siteName}
                        } catch (e) {
                          return null;
                        }
                    }"""
                )

                if article and article.get("content"):
                    clean_html = render_article_html(
                        title=article.get("title") or "Untitled",
                        content_html=article["content"],
                        source_url=url,
                    )
                    # Replace page with the clean reader view, then print.
                    page.set_content(clean_html, wait_until="load")
                else:
                    # Fallback: dump current page as-is (last resort).
                    typer.echo(
                        "    [!] Readability parse failed; printing original page."
                    )
                    # Use print CSS if present; otherwise still usable.

                # Generate PDF (Chromium-only API).
                page.pdf(
                    path=str(pdf_path),
                    format="A4",
                    print_background=True,
                    prefer_css_page_size=True,
                    margin={
                        "top": "12mm",
                        "right": "12mm",
                        "bottom": "16mm",
                        "left": "12mm",
                    },
                )
            except Exception as e:
                typer.echo(f"    [x] Failed: {e}")
            finally:
                page.close()

        ctx.close()
        browser.close()


@app.command(help="Install Chromium browser for Playwright (one-time).")
def install_browser() -> None:
    import subprocess
    import sys

    subprocess.check_call([sys.executable, "-m", "playwright", "install", "chromium"])
    typer.echo("Chromium installed for Playwright.")
